#!/usr/bin/env python3
"""
tmux-pane-title: Generate title for a specific pane based on its directory
"""

import json
import os
import subprocess
import sys
from pathlib import Path


def get_git_toplevel(directory):
    """Get git repository toplevel using git rev-parse"""
    try:
        result = subprocess.run(
            ['git', 'rev-parse', '--show-toplevel'],
            cwd=directory,
            capture_output=True,
            text=True
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except (subprocess.SubprocessError, FileNotFoundError):
        pass
    return None


def get_worktree_info(directory):
    """Get worktree name and relative path within the worktree"""
    git_root = get_git_toplevel(directory)
    if not git_root:
        return None, None
    
    git_root_path = Path(git_root)
    current_path = Path(directory)
    
    # Look for afm pattern in the git root specifically
    # First, try to find just "afm" (not afm-tools)
    for part in git_root_path.parts:
        if part == 'afm':  # Look for exact "afm" match first
            # Find the index of 'afm' in the path
            afm_index = git_root_path.parts.index(part)
            if afm_index + 1 < len(git_root_path.parts):
                # The next part after 'afm' should be the worktree name
                worktree_name = git_root_path.parts[afm_index + 1]
                # Skip 'master' as it's not descriptive
                if worktree_name != 'master':
                    # Calculate relative path from git root to current directory
                    try:
                        rel_path = current_path.relative_to(git_root_path)
                        if str(rel_path) == '.':
                            # At git root, show just the worktree name
                            return worktree_name, None
                        else:
                            # In subdirectory, show worktree/subdir
                            return worktree_name, str(rel_path)
                    except ValueError:
                        # current_path is not relative to git_root_path
                        return worktree_name, None
                    
    # Fallback: look for any part containing 'afm' if exact match failed
    for part in git_root_path.parts:
        if 'afm' in part and part != git_root_path.name:  # Skip the final afm-tools part
            # Find the index of 'afm' in the path
            afm_index = git_root_path.parts.index(part)
            if afm_index + 1 < len(git_root_path.parts):
                # The next part after 'afm' should be the worktree name
                worktree_name = git_root_path.parts[afm_index + 1]
                # Skip 'master' as it's not descriptive
                if worktree_name != 'master':
                    # Calculate relative path from git root to current directory
                    try:
                        rel_path = current_path.relative_to(git_root_path)
                        if str(rel_path) == '.':
                            # At git root, show just the worktree name
                            return worktree_name, None
                        else:
                            # In subdirectory, show worktree/subdir
                            return worktree_name, str(rel_path)
                    except ValueError:
                        # current_path is not relative to git_root_path
                        return worktree_name, None
    
    return None, None


def normalize_path(directory):
    """Normalize path by replacing /Users/mdejongh with ~"""
    home_path = "/Users/mdejongh"
    if directory.startswith(home_path):
        return directory.replace(home_path, "~", 1)
    return directory


def main():
    """Generate title for the given directory"""
    directory = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()
    
    worktree_name, subdir = get_worktree_info(directory)
    
    if worktree_name:
        if subdir:
            print(f"{worktree_name}/{subdir}")
        else:
            print(worktree_name)
    else:
        # Show the normalized path, but if it's just ~, show ~ not the basename
        normalized_path = normalize_path(directory)
        if normalized_path == "~":
            print("~")
        else:
            print(Path(normalized_path).name or normalized_path)


if __name__ == "__main__":
    main()