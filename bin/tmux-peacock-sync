#!/usr/bin/env python3
"""
tmux-peacock-sync: Sync tmux pane colors with VSCode Peacock extension colors
"""

import json
import os
import subprocess
import sys
from pathlib import Path
import re
import hashlib
import math


def hex_to_rgb(hex_color):
    """Convert hex color to RGB tuple"""
    hex_color = hex_color.lstrip('#')
    return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))


def rgb_to_hex(rgb):
    """Convert RGB tuple to hex color"""
    return f"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}"


def mute_color(hex_color, factor=0.3):
    """Mute a color by blending it with black"""
    r, g, b = hex_to_rgb(hex_color)
    # Blend with black to mute the color
    r = int(r * factor)
    g = int(g * factor)
    b = int(b * factor)
    return rgb_to_hex((r, g, b))


def hsl_to_hex(h, s, l):
    """Convert HSL to hex color"""
    # Normalize values
    h = h / 360.0
    s = s / 100.0
    l = l / 100.0
    
    def hue_to_rgb(p, q, t):
        if t < 0:
            t += 1
        if t > 1:
            t -= 1
        if t < 1/6:
            return p + (q - p) * 6 * t
        if t < 1/2:
            return q
        if t < 2/3:
            return p + (q - p) * (2/3 - t) * 6
        return p
    
    if s == 0:
        r = g = b = l  # achromatic
    else:
        q = l * (1 + s) if l < 0.5 else l + s - l * s
        p = 2 * l - q
        r = hue_to_rgb(p, q, h + 1/3)
        g = hue_to_rgb(p, q, h)
        b = hue_to_rgb(p, q, h - 1/3)
    
    return rgb_to_hex((int(r * 255), int(g * 255), int(b * 255)))


def generate_color_for_name(name):
    """Generate a distinctive color for a given name using golden ratio"""
    # Create a hash of the name for consistent color generation
    hash_val = hashlib.md5(name.encode()).hexdigest()
    # Use first 8 characters as a seed
    seed = int(hash_val[:8], 16)
    
    # Golden ratio conjugate for good distribution
    golden_ratio_conjugate = 0.618033988749895
    
    # Generate hue using golden ratio
    hue = (seed * golden_ratio_conjugate) % 1.0
    hue = hue * 360  # Convert to degrees
    
    # Use fixed saturation and lightness for good visibility
    saturation = 70  # 70% for vibrant colors
    lightness = 50   # 50% for good contrast
    
    return hsl_to_hex(hue, saturation, lightness)


def load_color_cache():
    """Load cached color assignments"""
    cache_file = Path.home() / '.config' / 'tmux-peacock-colors.json'
    try:
        if cache_file.exists():
            with open(cache_file, 'r') as f:
                return json.load(f)
    except (json.JSONDecodeError, IOError):
        pass
    return {}


def save_color_cache(cache):
    """Save color assignments to cache"""
    cache_file = Path.home() / '.config' / 'tmux-peacock-colors.json'
    try:
        # Ensure directory exists
        cache_file.parent.mkdir(parents=True, exist_ok=True)
        with open(cache_file, 'w') as f:
            json.dump(cache, f, indent=2)
    except IOError:
        pass  # Fail silently if we can't write cache


def create_vscode_settings_with_color(directory, color):
    """Create .vscode/settings.json with peacock color if it doesn't exist"""
    vscode_dir = Path(directory) / '.vscode'
    settings_file = vscode_dir / 'settings.json'
    
    try:
        # Create .vscode directory if it doesn't exist
        vscode_dir.mkdir(parents=True, exist_ok=True)
        
        # Load existing settings or create new ones
        settings = {}
        if settings_file.exists():
            with open(settings_file, 'r') as f:
                settings = json.load(f)
        
        # Add peacock color if not already present
        if 'peacock.color' not in settings:
            settings['peacock.color'] = color
            
            # Write back the settings
            with open(settings_file, 'w') as f:
                json.dump(settings, f, indent=2)
                
    except (json.JSONDecodeError, IOError, PermissionError):
        pass  # Fail silently if we can't create/modify settings


def get_worktree_name(directory=None):
    """Get git worktree name from directory path"""
    if directory is None:
        directory = os.getcwd()
    
    # Check if we're in a git worktree by looking for common patterns
    # Typical pattern: /path/to/project/worktree-name
    path = Path(directory)
    
    # Look for afm pattern specifically
    for part in path.parts:
        if 'afm' in part:
            # Find the index of 'afm' in the path
            afm_index = path.parts.index(part)
            if afm_index + 1 < len(path.parts):
                # The next part after 'afm' should be the worktree name
                worktree_name = path.parts[afm_index + 1]
                # Skip 'master' as it's not descriptive
                if worktree_name != 'master':
                    return worktree_name
    
    return None


def get_git_toplevel(directory):
    """Get git repository toplevel using git rev-parse"""
    try:
        result = subprocess.run(
            ['git', 'rev-parse', '--show-toplevel'],
            cwd=directory,
            capture_output=True,
            text=True
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except (subprocess.SubprocessError, FileNotFoundError):
        pass
    return None


def get_peacock_color(directory=None):
    """Get peacock color from VSCode settings, generating one if needed"""
    if directory is None:
        directory = os.getcwd()
    
    # Determine the target directory for VSCode settings (current or git root)
    target_directory = directory
    git_root = get_git_toplevel(directory)
    if git_root:
        target_directory = git_root
    
    # First try to load existing VSCode settings
    vscode_settings = Path(target_directory) / ".vscode" / "settings.json"
    existing_color = None
    
    if vscode_settings.exists():
        try:
            with open(vscode_settings, 'r') as f:
                settings = json.load(f)
            existing_color = settings.get('peacock.color')
        except (json.JSONDecodeError, IOError):
            pass
    
    # If we found an existing color, return it
    if existing_color:
        return existing_color
    
    # No existing color found, generate one
    # Use worktree name if available, otherwise use directory name
    worktree_name = get_worktree_name(directory)
    color_key = worktree_name if worktree_name else Path(target_directory).name
    
    # Load color cache
    cache = load_color_cache()
    
    # Check if we already have a color for this key
    if color_key in cache:
        generated_color = cache[color_key]
    else:
        # Generate new color and cache it
        generated_color = generate_color_for_name(color_key)
        cache[color_key] = generated_color
        save_color_cache(cache)
    
    # Create VSCode settings with the generated color
    create_vscode_settings_with_color(target_directory, generated_color)
    
    return generated_color


def normalize_path(directory):
    """Normalize path by replacing /Users/mdejongh with ~"""
    if directory is None:
        directory = os.getcwd()
    
    home_path = "/Users/mdejongh"
    if directory.startswith(home_path):
        return directory.replace(home_path, "~", 1)
    return directory


def set_tmux_pane_colors(color, worktree_name=None, directory=None):
    """Set tmux pane border colors and format for current session only"""
    # Set colors based on peacock color or defaults
    if color:
        # Mute the color for subtle borders
        muted_color = mute_color(color, 0.6)
        bright_color = mute_color(color, 0.8)
        
        # Set inactive pane border to muted color (session-specific)
        subprocess.run(['tmux', 'set-option', 'pane-border-style', f'fg={muted_color}'], 
                      capture_output=True)
        
        # Set active pane border to brighter version of the color (session-specific)
        subprocess.run(['tmux', 'set-option', 'pane-active-border-style', f'fg={bright_color}'], 
                      capture_output=True)
    else:
        # Use default colors when no peacock color
        subprocess.run(['tmux', 'set-option', 'pane-border-style', 'fg=colour240'], 
                      capture_output=True)
        subprocess.run(['tmux', 'set-option', 'pane-active-border-style', 'fg=colour250'], 
                      capture_output=True)
        bright_color = 'colour250'  # Use default bright color for text
    
    # Set a dynamic border format that calls our script for each pane's title
    # Each pane will show its own worktree name or directory basename
    border_format = f'#{{?pane_active,#[fg={bright_color}],#[fg=colour240]}}[ #(~/bin/tmux-pane-title "#{{pane_current_path}}") ]'
    subprocess.run(['tmux', 'set-option', 'pane-border-format', border_format], 
                  capture_output=True)


def main():
    """Main function"""
    # Check if we're in a tmux session
    if not os.environ.get('TMUX'):
        sys.exit(0)  # Silent exit if not in tmux
    
    # Create a simple lock to prevent multiple instances
    lock_file = Path("/tmp/tmux-peacock-sync.lock")
    try:
        if lock_file.exists():
            # Check if the lock is stale (older than 5 seconds)
            if (Path.stat(lock_file).st_mtime + 5) < os.path.getmtime("/tmp"):
                lock_file.unlink()
            else:
                sys.exit(0)  # Another instance is running
        
        lock_file.touch()
        
        directory = sys.argv[1] if len(sys.argv) > 1 else None
        peacock_color = get_peacock_color(directory)
        worktree_name = get_worktree_name(directory)
        
        # Always call set_tmux_pane_colors with all parameters
        # It will handle the logic internally
        set_tmux_pane_colors(peacock_color, worktree_name, directory)
            
    finally:
        # Clean up lock file
        if lock_file.exists():
            lock_file.unlink()


if __name__ == "__main__":
    main()